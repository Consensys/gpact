package crypto

/*
 * Copyright 2021 ConsenSys Software Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

import (
	"crypto/rand"
	"encoding/binary"
	"hash"
	"io"
	"math/big"
	"net"
	"time"

	"github.com/davidlazar/go-crypto/drbg"
)

// This file contains a Pseudo Random Number Generator (PRNG). The PRNG is a
// SP800-90a HMAC DRBG instance wrapped with a simple Psuedo Random Function (PRF).
// The reason for wrapping the DRBG in a PRF is to ensure random output even if
// the HMAC DRBG has been compromised. The PRF has been designed to not dillute the
// security strength of the DRBG.
//
// The PRNG should be reseeded regularly. The simplest way to do this is to call
// QuickReseedKick when things happen such as messages arrive from remove servers.

// Random is the interface for pseudo random number generators in this project.
type Random interface {
	ReadBytes(b []byte)
	Reseed(seed []byte)
	QuickReseedKick()
	GetReader() io.Reader
}

// RandomImpl holds the underlying DRBG and the PRF state.
type randomImpl struct {
	drbg       *drbg.DRBG
	prfHasher  hash.Hash
	prfState   []byte
	prfCounter *big.Int
}

// NewPRNG returns a new instance of the PRNG. The PRNG has a custom
// personalisation string, so identical instances on identical hardware should have
// differently seeded PRNGs.
func NewPRNG(securityDomain []byte) Random {
	personalizationString := securityDomain
	personalizationString = append(personalizationString, getMACAddr()...)
	personalizationString = append(personalizationString, nanotime()...)

	r := randomImpl{}
	r.drbg = drbg.New(personalizationString)
	r.prfCounter = big.NewInt(time.Now().UnixNano())
	r.prfHasher = getPRNGHasher()
	r.prfState = make([]byte, getPRNGHasherDigestSize())
	systemRandomBytes(r.prfState)
	return &r
}

// ReadBytes reads random values into b
func (r *randomImpl) ReadBytes(b []byte) {
	lengthPerIteration := len(r.prfState)
	lenOutput := len(b)

	ofs := 0
	for ofs < lenOutput {
		r.prfHasher.Reset()
		// Increment the PRF counter and add it to the message digest.
		r.prfCounter.Add(r.prfCounter, big.NewInt(1))
		r.prfHasher.Write(r.prfCounter.Bytes())

		// Get the output of the inner (untrusted DRBG) and add it to the message digest.
		drbgBytes := make([]byte, lengthPerIteration)
		r.drbg.Read(drbgBytes)
		r.prfHasher.Write(drbgBytes)

		// Incorporate the current state of the PRF into the message digest.
		r.prfHasher.Write(r.prfState)
		hashOutput := r.prfHasher.Sum(nil)

		// Update the PRF state.
		r.prfState = hashOutput

		oldOfs := ofs
		ofs += lengthPerIteration

		// If the output length
		if ofs <= lenOutput {
			copy(b[oldOfs:ofs], hashOutput)
		} else {
			copy(b[oldOfs:lenOutput], hashOutput)
		}
	}
}

// Read reads random values into b
func (r *randomImpl) Read(b []byte) (n int, err error) {
	r.ReadBytes(b)
	return len(b), nil
}

// Reseed adds seed material to the PRNG.
func (r *randomImpl) Reseed(seed []byte) {
	r.drbg.Reseed(seed)

	// Combine the current state of the PRF and the seed.
	r.prfHasher.Reset()
	r.prfHasher.Write(seed)
	r.prfHasher.Write(r.prfState)
	hashOutput := r.prfHasher.Sum(nil)
	r.prfState = hashOutput
}

// QuickReseedKick aims to execute in a small amount of time and should add a few bits
// of entropy to the entropy pool. The idea is to call this low cost function regularly
// to overall gather lots of entropy.
func (r *randomImpl) QuickReseedKick() {
	r.Reseed(nanotime())
}

// GetReader returns a reader than can be passed around in place of rand.Reader
func (r *randomImpl) GetReader() io.Reader {
	return r
}

// Nano time as bytes
func nanotime() []byte {
	// Get the time now as accurately as Golang and the CPU will allow. For some systems
	// this will be tens of ns, some will be single us, and some will only update this
	// timer ever several tens of ms.
	nowNano := time.Now().UnixNano()
	bytes := make([]byte, 8)
	binary.BigEndian.PutUint64(bytes, uint64(nowNano))
	return bytes
}

// Use the bytes from the first interface.
func getMACAddr() []byte {
	var result []byte
	ifas, err := net.Interfaces()
	if err != nil {
		panic(err)
	}
	for _, ifa := range ifas {
		if ifa.HardwareAddr != nil {
			result = append(result, ifa.HardwareAddr...)
		}
	}
	return result
}

// Return random bytes generated by the PRNG that comes with golang.
func systemRandomBytes(b []byte) {
	_, err := rand.Read(b)
	if err != nil {
		panic(err)
	}

}
