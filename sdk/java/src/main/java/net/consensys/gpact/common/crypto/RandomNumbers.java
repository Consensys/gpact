/*
 * Copyright 2019 ConsenSys Software Inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */
package net.consensys.gpact.common.crypto;

import static java.security.DrbgParameters.Capability.RESEED_ONLY;

import com.google.common.primitives.Bytes;
import com.google.common.primitives.Ints;
import com.google.common.primitives.Longs;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.nio.BufferOverflowException;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.security.*;
import java.util.Arrays;
import java.util.Enumeration;
import org.bouncycastle.jce.provider.BouncyCastleProvider;

/** Implements good PRNG sources. */
public class RandomNumbers {
  private static final byte[] networkMacs;
  private static final SecureRandom privateRand;
  private static final SecureRandom publicRand;

  static {
    if (Security.getProvider(BouncyCastleProvider.PROVIDER_NAME) == null) {
      Security.addProvider(new BouncyCastleProvider());
    }

    try {
      // Fetch the hardware addresses once as it could be time consuming.
      networkMacs = networkHardwareAddresses();
      // Always have available the random number generators for secret values
      // and public values.
      privateRand = newPrng("private");
      publicRand = newPrng("public");
    } catch (final Exception e) {
      throw new RuntimeException(e);
    }
  }

  private RandomNumbers() {}

  /**
   * Return a PRNG that should only be used for generating secret values such as keys.
   *
   * @return Private value PRNG
   */
  public static SecureRandom getPrivateRand() {
    return privateRand;
  }

  /**
   * Return a PRNG that should only be used for generating values that become public such as salts,
   * crytographic nonces, and initialisation vectors.
   *
   * @return Public value PRNG
   */
  public static SecureRandom getPublicRand() {
    return privateRand;
  }

  /**
   * Create a PRNG for a separate security domain.
   *
   * @param prngName Name to use for the PRNG. This must be different from all other PRNG names. It
   *     could be application name contatenated with what the PRNG is going to be used for.
   * @return Newly created PRNG.
   */
  public static SecureRandom getNewRand(byte[] prngName) {
    return privateRand;
  }

  /** Reseed the private PRNG. Note: Call this between usages of the PRNG. */
  public static void quickReseedPrivateRand() {
    quickReseed(privateRand);
  }

  /** Reseed the public PRNG. Note: Call this between usages of the PRNG. */
  public static void quickReseedPublicRand() {
    quickReseed(publicRand);
  }

  /** Reseed a PRNG. Note: Call this between usages of the PRNG. */
  public static void quickReseed(final SecureRandom rand) {
    final byte[] memPointer = Ints.toByteArray((new Object()).hashCode());
    final byte[] now = Longs.toByteArray(System.nanoTime());
    final byte[] seed = Bytes.concat(memPointer, now);
    rand.setSeed(seed);
  }

  /**
   * Generate a random byte array using the public PRNG.
   *
   * @param numBytes Number of random bytes to generate.
   * @return Randomly generated byte array.
   */
  public static byte[] generatePublicRandomBytes(final int numBytes) {
    quickReseedPublicRand();
    byte[] randBytes = new byte[numBytes];
    publicRand.nextBytes(randBytes);
    return randBytes;
  }

  /**
   * Use a personalisation string to help ensure the entropy going into the PRNG is unique.
   *
   * @param name A name to use for the PRNG. This must be different from all other PRNG names. It
   *     could be application name contatenated with what the PRNG is going to be used for.
   */
  private static byte[] getPersonalizationString(final byte[] name) {
    final Runtime runtime = Runtime.getRuntime();
    final byte[] threadId = Longs.toByteArray(Thread.currentThread().getId());
    final byte[] availProcessors = Ints.toByteArray(runtime.availableProcessors());
    final byte[] freeMem = Longs.toByteArray(runtime.freeMemory());
    final byte[] runtimeMem = Longs.toByteArray(runtime.maxMemory());
    return Bytes.concat(threadId, availProcessors, freeMem, runtimeMem, networkMacs, name);
  }

  private static byte[] networkHardwareAddresses() throws SocketException, BufferOverflowException {
    final byte[] networkAddresses = new byte[256];
    final ByteBuffer buffer = ByteBuffer.wrap(networkAddresses);

    final Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();
    while (networkInterfaces.hasMoreElements()) {
      final NetworkInterface networkInterface = networkInterfaces.nextElement();
      final byte[] hardwareAddress = networkInterface.getHardwareAddress();
      if (hardwareAddress != null) {
        buffer.put(hardwareAddress);
      }
    }
    return Arrays.copyOf(networkAddresses, buffer.position());
  }

  private static SecureRandom newPrng(final String name) throws Exception {
    return SecureRandom.getInstance(
        "DRBG",
        DrbgParameters.instantiation(
            256, RESEED_ONLY, getPersonalizationString(name.getBytes(StandardCharsets.UTF_8))));
  }
}
